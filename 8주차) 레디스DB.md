
2021/05/16

- 장원용 프로

# redis DB
- Key, Value 형태로 저장하는 인메모리 스토어
- Key 값이 너무 많으면 장애가 발생할 수 있음
- 싱글스레드로 구성되어 사용에 있어 주의해야 함

## 캐싱 전략
- redis 는 영구적인 저장도 쓰이지만 캐싱을 이용하는데 주로 사용된다.
- 캐싱이란 메모리에서 해당 데이터를 빠르게 찾아서 Disk IO 에 비해 적은 비용으로 처리하는 것이다.
- 사용자가 증가할 경우, 캐싱이 아닌 DB 접근만으로 처리하면 부하가 생긴다.
- 파레토 법칙이란 80퍼센트의 결과는 20퍼센트의 원인으로 발생한다는 것인데, 20퍼센트 고객이 전체 매출의 80퍼센트 매출 결과를 일으킨다는 것이다.
- 즉, 성능 문제를 일으키는 것은 20퍼센트의 쿼리들이다.

### Look Aside
- 데이터를 먼저 redis 에 있는지 확인하여 Hit 할 경우 메모리 데이터를 내보내고, 없으면 DB 로부터 읽어서 캐싱한 후 내보낸다.
- 데이터가 없는 경우 2번 봐야하지만, 장점이 커버할 수 있는 정도이다.
- 하지만 데이터 변경이 자주 일어나는 시스템에서는 redis 를 먼저 보기 때문에 변경내역을 모를 수 있다.
- 따라서 Read 가 많은 시스템에 적절한 전략이다.

### Write-Back
- Write 를 한번 한번 하지않고, 쌓아두었다가 묶어서 한번에 하는 방식이다.
- Write 가 많은 시스템에 적절한 전략이다.

### Session Management
- 자주 사용되는 전략이다.
- Session 을 레디스를 사용하지 않고 관리하면 서버 메모리에 저장되서 관리가 되는 경우가 많다.
- 따라서, 세션 ID 를 쿠키값으로 사용자에게 내려주고 사용자는 request 안에 해당 쿠키를 넣어서 보내주어 해당 값을 보고 서버에서 확인하게 된다.
- 메모리는 휘발성이기 때문에 로그인 후에도 갑자기 날아가게 될 수 있고 여러 서버에 클러스터링 및 세션 공유를 해줘야한다.
- redis 를 사용하게되면 이러한 세션 공유 전략을 사용하거나 복구 전략을 구성할 때도 편하다.

### redis 자료구조
- redis 는 Collection 을 지원한다. 즉, key 값에 대한 value 를 Collection 형태로 저장할 수 있다.
- ex) 랭킹서버의 경우, Solted Set 을 이용하여 인메모리에 특정 값으로 정렬된 랭킹값을 가지고 있으면 빠르게 처리할 수 있다.
- 싱글스레드인 redis 에서 부하가 가면 이후 Task 에도 영향이 가므로 가능하면 하나의 Collection 에 만개 이하의 몇천개 수준의 데이터셋을 유지하는게 좋다.
- Expire 에 경우 Collection 전체 값에 처리되므로 Expire 전략 구성 시, 조심해야한다.
- KEYS 를 쓰는 순간 데이터가 많은 쪽에서는 장애가 발생하므로 Scan 명령어를 사용해야 한다.
- Spark 와 같이 실시간 데이터 처리에서 데이터 손실이 일어날 수 있으므로 해당 경우에 redis 를 보조적으로 사용하기도 한다.
- 각 코멘트에 좋아요를 하나 표시할 수 있을 때, Collection Set 에 게시물 ID KEY 를 이용하고 조회 처리 속도를 단축할 수 있다.
- Jedis 등과 같은 라이브러리를 이용하여 처리를 하기도 한다.
- bit 를 이용하여 일일 순 방문자 수를 구하기도 한다.
- ID, 날짜별 정리 및 중복제거 등 을 해야한다고 할때 방문자별로 bit 를 하나 만들어서 방문자 하나씩으로 생각하여 redis 의 BITCOUNT 연산을 이용하여 그날 방문하였던 사용자 수를 빠르게 구해올 수 있다.